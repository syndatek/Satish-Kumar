/*
 * sydantek.c
 *
 * Copyright (c) 2020 and onwards, Carditek Medical Devices, Pvt. Ltd.
 * All rights reserved.
 */




/******************************************************************************

 @file       heart_rate.c

 @brief This file contains the Heart Rate sample application for use with the
        CC26xx Bluetooth Low Energy Protocol Stack.

 Group: CMCU, SCS
 Target Device: CC2640R2

 ******************************************************************************

 Copyright (c) 2011-2017, Texas Instruments Incorporated
 All rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions
 are met:

 *  Redistributions of source code must retain the above copyright
    notice, this list of conditions and the following disclaimer.

 *  Redistributions in binary form must reproduce the above copyright
    notice, this list of conditions and the following disclaimer in the
    documentation and/or other materials provided with the distribution.

 *  Neither the name of Texas Instruments Incorporated nor the names of
    its contributors may be used to endorse or promote products derived
    from this software without specific prior written permission.

 THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

 ******************************************************************************
 Release Name: simplelink_cc2640r2_sdk_ble_example_pack_01_50_00_62
 Release Date: 2017-11-01 10:38:41
 *****************************************************************************/

/*********************************************************************
 * INCLUDES
 */
#include <string.h>

#include <ti/sysbios/knl/Task.h>
#include <ti/sysbios/knl/Clock.h>
#include <ti/sysbios/knl/Event.h>
#include <ti/sysbios/knl/Queue.h>
#include <ti/display/Display.h>

#include <icall.h>
#include "util.h"
/* This Header file contains all BLE API and icall structure definition */
#include "icall_ble_api.h"

//#include "peripheral.h"
#include "devinfoservice.h"


#include <ti/drivers/SPI.h>
#include <ti/drivers/spi/SPICC26XXDMA.h>
#include <ti/drivers/dma/UDMACC26XX.h>

#include <ti/drivers/GPIO.h>
#include <driverLib/timer.h>
#include <ti/drivers/pin/PINCC26XX.h>
#include <ti/sysbios/family/arm/m3/Hwi.h>
#include <ti/sysbios/knl/Swi.h>
#include <xdc/runtime/Error.h>
#include <ti/sysbios/knl/Semaphore.h>
//#include <ti/ble5stack/boards/CC2640R2_LAUNCHXL/CC2640R2_LAUNCHXL.h>

#include <uartlog/UartLog.h>
#include <icall.h>
#include <icall_ble_api.h>
/* Application specific includes */

#include <services/sydantek.h>



// 251 - 3-byte ATT notification header, 4 byte L2CAP header.
#define PAYLOAD_BYTES         244

typedef struct __attribute__((__packed__)) {
    uint16_t version;  // has to be 1
    uint16_t leads;    // 1, 2 or 8
    uint16_t limb_hz;  // 500, 1000, 2000
    uint16_t chest_hz; // 500, 1000, 2000
} params_t;

#define SERVICE_INDEX         0
#define PARAMS_INDEX          1
#define NOTIFY_INDEX          2

static CONST uint8_t service_uuid[] = { SYDANTEK_UUID(SERVICE_INDEX) };
static CONST uint8_t params_uuid[] = { SYDANTEK_UUID(PARAMS_INDEX) };
static CONST uint8_t notify_uuid[] = { SYDANTEK_UUID(NOTIFY_INDEX) };

// Characteristic values & configuration.
static params_t params = { 1, 2, 500, 500 };
static uint8_t notify[1];  // not really used.
static gattCharCfg_t* notify_config;


int  iflag=1;

char fDRYCount;

#define SPIDMAABORT_T  20//which is 40 milisecond


//#define enabling  singal internal and external not enabled
#define INTERNAL_TEST_SIGNAL    0x10    //0x10 is test signal enabled
#define INTERNAL_TEST_SIGNAL_CH 0x15    //Internal Test Tone gain set 1

#define EXTERNAL_TEST_SIGNAL 0x00     //0x10 is test signal enabled



#define EXTERNAL_SIG         0x10  //external gain set 1
#define CH_GAIN              0x10


#define NOISE_MEASUREMENT    0x11  //CHnSET to  01 for noise Measurement cal
#define VOLTAGE_MEASUREMENT  0x13  //CHnSET Voltage Voltage Meaurement
#define TEMP_MEASUREMENT     0x14  //CHnSET Voltage TEMP Meaurement
#define CH_PDWN              0x80

#define CH2_P_RLD           0x06  // channel 2 positive to RLD Driver
#define CH2_N_RLD           0x07  // channel 2 positive to RLD Driver

#define RLD_AMP_ENABLED     0x40  //RLD Ampilfier enabled

int iSPIDMAAbortCnt;

//char cTempBfr[6][27]; //instaneously frames are loaded
uint8_t cTempBfr[8][30]; // channel on 1 -8 can be18 bytes to be collected to get Send the data
char cPenidingEvtf=0;
int iPacketNumber1Copy;

//static uint16  ECG_Sample_Count1=0,ECG_Sample_Count2=0,ECG_Sample_Count3=0;
//-------------------SLP 15 Feb 16
uint8 delay_count;
uint8 LED_State=1;
uint8 Board_SPI=0;

extern PIN_State pinState;

//GPIOCC26XX_Config
//GPIOCC26XX_config

extern PIN_Handle hCpuPins;


//PIN_Config gpiotable;
PIN_Config gpiotable[] = { PIN_TERMINATE };

PIN_Handle hEtagPins;
PIN_State  EtagPins;




UART_Params UART_Stting;                //slp 9 feb 16
UART_Handle     Uhandle;                 //slp 9 feb 16


//-----------------Hardware interrupt setup
Hwi_Handle hwiDRDY;
Hwi_Params hwiParams;
Error_Block eb;



//-----------------Software INterrupt Setup
Swi_Handle hswiDRDY;
Swi_Handle hSPIover;
Swi_Params swiParams;



//--------------------------


//uint8_t txBuf[27] = {0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27};    // Transmit buffer
uint8_t txBuf[27];
uint16_t Sampleindex=0;

uint16 Packet_Count;
uint16 Sample_data1;
uint16 Sample_data2;
uint16 Brpckt_Num;
uint16 delay1,delay2;
uint8 index=0;
uint16 Sim_Data=0;
uint8_t command_recieved_flag=0;
uint8_t AFE_Toggle=0;
uint8_t Frame_Pointer;          //SLP 16 Aug 16
uint8_t Buff_Change_Flag=0;     //SLP 17 Aug 16

uint8_t cSpiTxBuffer[30];
uint8_t cSpiRxBuffer1[30];
uint8_t cSpiRxBuffer2[30];
uint8_t cExternalbuffer[27];
SPI_Handle spiHandle;
uint8 SPI0=0;
uint8 SPI1=1;
uint8_t iSPIStatus;
int iPacketNumber=0;
int iPacketNumber1[8];

char cIDCountDisplay=0,cFailcount=0; //displayAfe ad1298 id to ble for 20 times
unsigned char cAFE_ID=0xff; //default ot 0xff
float f1,f2;


char iData_Not_Arrived; //if data  is not arrived in 50 m/s

//-----------
uint16_t iDataPointer;
int iInGetData,iInNextScanBuffer;
//------------

uint8_t NextScanBuffer(void);
inline void OneDataNotificationCorrected160bytes(void);
int AFEinit3(void);
int SendtoAFE (SPI_Handle handle1, uint8 iSendCount,uint8 iRecvCount);
int GetDataFromScanBuffer(void);




PIN_Config BoardGpioInitTable1[]={



       CONFIG_PIN_BTN1 | PIN_GPIO_OUTPUT_EN | PIN_GPIO_LOW  | PIN_PUSHPULL| PIN_DRVSTR_MED,
                                  //      /* Parent Signal: AFE_RESET GPIO Pin, (DIO7) */
       CONFIG_PIN_RLED | PIN_GPIO_OUTPUT_EN | PIN_GPIO_LOW | PIN_PUSHPULL | PIN_DRVSTR_MED,
                                  //      /* Parent Signal: AFE_PRDWN GPIO Pin, (DIO10) */
       CONFIG_PIN_GLED | PIN_GPIO_OUTPUT_EN | PIN_GPIO_LOW | PIN_PUSHPULL | PIN_DRVSTR_MED,


       CONFIG_PIN_BTN2 | PIN_INPUT_EN |PIN_NOPULL | PIN_IRQ_NEGEDGE,




   PIN_TERMINATE
};





//---------------
/*********************************************************************
 * EXTERNAL VARIABLES
 */
 SPI_Handle      handle_spi;
 SPI_Params      params_spi;
 SPI_Transaction transaction;

/*********************************************************************
 * GLOBAL VARIABLES
 */

// Display Interface
Display_Handle dispHandle = NULL;

/*********************************************************************
 * EXTERNAL VARIABLES
 */

/*********************************************************************
 * TYPEDEFS
 */


bool bDataReadinProgress;
unsigned int iPacketNumber2;
char chr0x33;
int iIntCount;
int  iSpiCount;
uint8_t *ptrbuf,ptrbuf1;
char cSpiTxferCmplete;
char cBleTxferCmplete;
 void DRDY_Callback(PIN_Handle hPin, PIN_Id pinId);







int iPacketNumberCopy=0;
char cfailCount=0;

// Event globally used to post local events and pend on system and
// local events.
static ICall_SyncHandle syncEvent;


static Clock_Struct battPerClock;

unsigned int cDebug;

/*********************************************************************
 * LOCAL FUNCTIONS
 */



void AFE_performPeriodicTask(void);
int ReadDataFromAFE(void);
int ReadDataFromAFEasynchronous(void);
int ReadDataFromAFEasynchronous_Debug(void);
//static void AFEinit_taskFxn(UArg a0, UArg a1);


volatile void swiDRDYFunction();
int AFEinit(void);
int AFEinit1(void);
int SendtoAFE2 (uint8 iSendCount,uint8 iRecvCount);
int AFEinit2(void);
//int SendtoAFE (SPI_HANDLE uint8 iSendCount,uint8 iRecvCount)
int cInterruptNumber;
unsigned char cInterprocessSem=0;
//extern hciStatus_t HCI_EXT_HaltDuringRfCmd( uint8 mode );








strScanBuffer ScanBuffer;



static uint8_t attribute_index(const gattAttrType_t* type) {
    if (type->len != ATT_UUID_SIZE) return 0xff;

    // All SYDANTEK_UUID bytes except the LSB should be identical.
    if (memcmp(type->uuid + 1, service_uuid + 1, ATT_UUID_SIZE - 1) != 0)
        return 0xff;
    return type->uuid[0];
}

static bStatus_t ReadAttribute(uint16_t handle, gattAttribute_t *attribute,
                               uint8_t *value, uint16_t *length,
                               uint16_t offset, uint16_t max_length,
                               uint8_t method)
{
    switch (attribute_index(&attribute->type)) {
    case PARAMS_INDEX:
        if (offset >= sizeof(params_t))
            return ATT_ERR_INVALID_OFFSET;
        *length = MIN(max_length, sizeof(params_t) - offset);
        memcpy(value, attribute->pValue + offset, *length);
        return SUCCESS;
    default:
        return ATT_ERR_ATTR_NOT_FOUND;
    }
}

static bStatus_t WriteAttribute(uint16_t handle, gattAttribute_t *attribute,
                                uint8_t *value, uint16_t length,
                                uint16_t offset, uint8_t method)
{
    if (attribute->type.len == ATT_BT_UUID_SIZE
            && *(uint16_t*) attribute->type.uuid == GATT_CLIENT_CHAR_CFG_UUID) {
        return GATTServApp_ProcessCCCWriteReq(
                handle, attribute, value, length, offset, GATT_CLIENT_CFG_NOTIFY);

    }

    switch (attribute_index(&attribute->type)) {
    case PARAMS_INDEX:
        if (offset >= sizeof(params_t))
            return ATT_ERR_INVALID_OFFSET;
        length = MIN(length, sizeof(params_t) - offset);
        memcpy(attribute->pValue + offset, value, length);
        return SUCCESS;
    default:
        return ATT_ERR_ATTR_NOT_FOUND;
    }
}

static gattAttribute_t attributes[] =
{
    {
        { ATT_BT_UUID_SIZE, primaryServiceUUID },
        GATT_PERMIT_READ,
        0,
        (uint8_t*) &(gattAttrType_t) { ATT_UUID_SIZE, service_uuid }
    },
    {
        { ATT_BT_UUID_SIZE, characterUUID },
        GATT_PERMIT_READ,
        0,
        &(uint8) { GATT_PROP_READ | GATT_PROP_WRITE }
    },
    {
        { ATT_UUID_SIZE, params_uuid },
        GATT_PERMIT_READ | GATT_PERMIT_WRITE,
        0,
        (uint8_t *) &params
    },
    {
        { ATT_BT_UUID_SIZE, characterUUID },
        GATT_PERMIT_READ,
        0,
        &(uint8) { GATT_PROP_NOTIFY | GATT_PROP_WRITE_NO_RSP }
    },
    {
        { ATT_UUID_SIZE, notify_uuid },
        GATT_PERMIT_WRITE,
        0,
        notify
    },
    {
        { ATT_BT_UUID_SIZE, clientCharCfgUUID },
        GATT_PERMIT_READ | GATT_PERMIT_WRITE,
        0,
        (uint8_t *) &notify_config
    },
};

static CONST gattServiceCBs_t callbacks =
        { ReadAttribute, WriteAttribute, NULL };

bStatus_t Sydantek_AddService(uint8_t rspTaskId)
{
    uint8_t status = SUCCESS;

    notify_config = (gattCharCfg_t *) ICall_malloc(
            sizeof(gattCharCfg_t) * linkDBNumConns);
    if (notify_config == NULL)
        return bleMemAllocError;
    GATTServApp_InitCharCfg(LINKDB_CONNHANDLE_INVALID, notify_config);

    status = GATTServApp_RegisterService(
            attributes, GATT_NUM_ATTRS(attributes), GATT_MAX_ENCRYPT_KEY_SIZE,
            &callbacks);
    Log_info2("Registered service, %d attributes, status=%d",
              GATT_NUM_ATTRS(attributes), status);
    return status;
}





/**--------------------------------------------------------------
void AFEChipSelect(void)
Selcts teh Active Low Chip select Pin of teh AFE
input: none
returns:nothing
----------------------------------------------------------------*/
void AFEChipSelect(void)
{
    PIN_setOutputValue(hCpuPins,3,0);
    //PIN_setOutputValue(hCpuPins,AFE_CS_EVALBOARD,0);
}

/**----------------------------------------------------------------
void AFEChipSelect(void)
DeSelcts teh Active Low Chip select Pin of the AFE
input: none
returns:nothing
----------------------------------------------------------------*/
void AFEChipUnSelect(void)
{
    PIN_setOutputValue(hCpuPins,3,1);
    //PIN_setOutputValue(hCpuPins,AFE_CS_EVALBOARD,1);
}

/**----------------------------------------------------------------
void ConnectPowertoAFE(void)
Enables 3.3V output by controlling BOard 3.3V enable pin on CPUGenerates
When this ppin is made 0, 3.3V is enabled
input: none
returns:nothing
----------------------------------------------------------------*/
void ConnectPowertoAFE(void)
{
        //keep digital bits low on power on
    //PIN_setOutputValue(hCpuPins,CONFIG_PIN_3,1);//CONFIG_SPI_0 MOSI

    //PIN_setOutputValue(hCpuPins,CONFIG_PIN_1,1);//CONFIG_SPI_0 SCLK
    //PIN_setOutputValue(hCpuPins,CONFIG_PIN_12,1);//CONFIG_SPI_0 CS

    //PIN_setOutputValue(hCpuPins,3,1);//CONFIG_SPI_0 CSAFE_CS
    //PIN_setOutputValue(hCpuPins,3,0);//CONFIG_SPI_0 CSAFE_CS

    PIN_setOutputValue(hCpuPins,0,0);//CONFIG_SPI_0 MOSI
    PIN_setOutputValue(hCpuPins,1,0);//CONFIG_SPI_0 SCLK
    PIN_setOutputValue(hCpuPins,3,0);//CONFIG_SPI_0 CS
    //PIN_setOutputValue(hCpuPins,Board_3V3_EN,1);        //3.3 V is to kept enabled for AFE to work
}
/**---------------------------------------------------------------
void Delayus(int iDelay)
Routine to give so many us delay
input: int iDelay -- numner of uS
returns:nothing
----------------------------------------------------------------!*/
void DelayuS(int iDelay)
{
 uint32_t i,j,k;
for (i=0,j=0,k=0;i<=iDelay;i++){
    j=i*8;
    k=k+j;
}
}


//-------------------------------------------------------------------
//static void KeepPinsReady(void)
//--------------------------------------------------------------------
void KeepPinsReady(void)
{
    //PIN_Close(&pinState);
    //hCpuPins= PIN_open(&pinState,gpiotable);
    //hCpuPins= PIN_open(&pinState,BoardGpioInitTable1);


}


/**----------------------------------------------------------------
void ResetAFE(void)
Generates Hadr=ware Reset signal for AFE
input: none
returns:nothing
----------------------------------------------------------------*/
void HardwareResetAFE(void)
{
//    KeepPinsReady();
//    ConnectPowertoAFE();
//
//    PIN_setOutputValue(hCpuPins,AFE_RESET,0);
//    DelayuS(100);
//    PIN_setOutputValue(hCpuPins,AFE_RESET,1);
//    DelayuS(100);

        KeepPinsReady();
        ConnectPowertoAFE();
        PIN_setOutputValue(hCpuPins,7,0);

        DelayuS(100000);
        PIN_setOutputValue(hCpuPins,7,1);
        DelayuS(100000);


}
/**-------------------------------------------------------------
void AFEstart(void)
High-low-High pulse on Start line starts the ADC
input: none
returns:nothing
----------------------------------------------------------------*/
void AFEstart(void)
{

    PIN_setOutputValue(hCpuPins,6,0);       // AFE start is doen by sending command
                                                    // For command to be accepted, this line is to be kept low
    DelayuS(1);
    //PIN_setOutputValue(hCpuPins,AFE_START,1);
    //DelayuS(100);
    cSpiTxBuffer[0] = AFE_OPCODE_START;
    SendtoAFE (handle_spi,1,0);                                 //restart continuous read

}


/**----------------------------------------------------------------------
 * void SendtoAFE2 (uint8 iCount, uint8* ptr)
 * Rountien send number of bytes to AFE
 * input: iCount: no of bytes to be sent
 *  returns: AFE_TRANSFER_ERR(-1) if transfer counld not take palce
 *          else, no. of bytes that have bene received as reply
 *          (0 or more- depends on iRecv COunt specified)
 ----------------------------------------------------------------------*/
int SendtoAFE2 (uint8 iSendCount,uint8 iRecvCount)
{
    int i;
    bool b1;

    uint8_t cTempTx[100],cTempRx[100];


    for (i=0;i<iSendCount+iRecvCount;i++){
        cTempTx[i]=0x00;
        cTempRx[i]=0xFF;
    }
    for (i=0;i<iSendCount;i++){
        cTempTx[i]=cSpiTxBuffer[i];
    }

    transaction.count = iSendCount+iRecvCount;
    transaction.txBuf = cTempTx;
    transaction.rxBuf = cTempRx;

    b1=SPI_transfer(handle_spi, &transaction);
    if (!b1) {
        return AFE_TRANSFER_ERR;                       // returns error condition
    }

    for (i=0;i<iRecvCount;i++){
        cSpiRxBuffer1[i]=cTempRx[i+iSendCount]; // ignore the response of MISO for sent bytes and consider only received bytes
    }
    cSpiRxBuffer1[i]=cTempRx[i];
    cAFE_ID=cSpiRxBuffer1[0];
    cAFE_ID=cSpiRxBuffer1[0]; //for breakpoint

    //---------------
    return iRecvCount;                          // no. of bytes that has been received
}

/**----------------------------------------------------------------------
 * void SendtoAFE (uint8 iCount, uint8* ptr)
 * Rountien send number of bytes to AFE
 * input: iCount: no of bytes to be sent
 *  returns: AFE_TRANSFER_ERR(-1) if transfer counld not take palce
 *          else, no. of bytes that have bene received as reply
 *          (0 or more- depends on iRecv COunt specified)
 ----------------------------------------------------------------------*/
int SendtoAFE (SPI_Handle handle1, uint8 iSendCount,uint8 iRecvCount)
{
int i;
bool b1;

    uint8_t cTempTx[100],cTempRx[100];
    for (i=0;i<iSendCount+iRecvCount;i++){
        cTempTx[i]=0x00;
        cTempRx[i]=0xFF;
    }
    for (i=0;i<iSendCount;i++){
        cTempTx[i]=cSpiTxBuffer[i];
    }

    transaction.count = iSendCount+iRecvCount;
    transaction.txBuf = cTempTx;
    transaction.rxBuf = cTempRx;

    b1=SPI_transfer(handle_spi, &transaction);
    if (!b1) return AFE_TRANSFER_ERR;                       // returns error condition

    for (i=0;i<iRecvCount;i++){
        cSpiRxBuffer1[i]=cTempRx[i+iSendCount]; // ignore the response of MISO for sent bytes and consider only received bytes
    }
    cSpiRxBuffer1[i]=cTempRx[i];
    //---------------
    return iRecvCount;                          // no. of bytes that has been received
}


/**----------------------------------------------------------------
void ResetScanBuffer(void)
Used to initialise scan buffer
input: none
returns: nothing
 -----------------------------------------------------------------*/
void ResetScanBuffer(void)
{
    ScanBuffer.iIptr=0;         // both in and out pointers are pointing to beginning of scan buffer
    ScanBuffer.iOptr=0;
    ScanBuffer.iOverrunFlag=0;
    ScanBuffer.iCount=0;
}


/**-----------------------------reset the afe-------------------------------*/
void ResetAFE(void)
{

    PIN_setOutputValue(hCpuPins,10,1);
    PIN_setOutputValue(hCpuPins,7,1);
    DelayuS(100);
    PIN_setOutputValue(hCpuPins,7,0);
    DelayuS(1000);
    PIN_setOutputValue(hCpuPins,7,1);
    DelayuS(100);

}

/**---------------------------------------------------------------
uint8_t* NextScanBuffer(void)
points to 27 byte buffer in scan buffer into which data has to e put next
Uses ScanBuffer.iIptr as index
Increments the iIPtr index until it reaches  iOptr
input: none
returns:return 1 if buffer is found. return 0 if buffer is not found. the buffer address is retunred in global variable ptr buf
 ----------------------------------------------------------------*/
uint8_t NextScanBuffer(void)
{
 uint8_t * ptr;
int i,j,k;
    k=0;
    ptr=0;
    //if (iInGetData==1) return 0;
    iInNextScanBuffer=1;
    i=ScanBuffer.iIptr;
    ptr=&(ScanBuffer.ScanData[i].cOneScanData[0]);

    j=ScanBuffer.iCount;
    if (j>SCAN_BUF_SIZE) {
        k=1;
        iInNextScanBuffer=0;
        ScanBuffer.iOverrunFlag=1;
        return 0;
    }

    if (j<0) {
        ResetScanBuffer();
        i=ScanBuffer.iIptr;
        ptr=&(ScanBuffer.ScanData[i].cOneScanData[0]);
        ptrbuf=ptr;
        ScanBuffer.iOverrunFlag=2;
        iInNextScanBuffer=0;
        return 1;
    }



    j++;
    ScanBuffer.iOverrunFlag=0;

    iInNextScanBuffer=0;
    ptrbuf=ptr;

    return 1;

}


/**-----------------------------------------------------------------------------------
void swiDRDYFunction()
Call back fucntion gets control every time DRDY interrupt is generated,
HWI interrupt servcie routine is executed, which posts the SWI *
 -------------------------------------------------------------------------------------*/
volatile void swiDRDYFunction()
{

    ReadDataFromAFEasynchronous();



}


/**----------------------------------------------------------------
static void DRDY_Callback(PIN_Handle hPin, PIN_Id pinId)
Call back function - gets control on DRDY interrupt
input: none
returns:nothing
----------------------------------------------------------------*/
void DRDY_Callback(PIN_Handle hPin, PIN_Id pinId)

//void DRDY_Callback(uint_least8_t index)
{


  Swi_post(hswiDRDY);


}



/**----------------------------------------------------------------------
 * int ReadDataFromAFEasynchronous(void)
 * Read the
 * input: iCount: no of bytes to be sent
 * returns: AFE_TRANSFER_ERR(-1) if transfer counld not take palce
 *          else, no. of bytes that have bene received as reply
 *          (0 or more- depends on iRecv COunt specified)
 ----------------------------------------------------------------------*/
int ReadDataFromAFEasynchronous(void)
{
int i;
    bool b1;


    uint8_t cTempTx[AFE_DATA_LENGTH];
    uint8_t cTempRx[AFE_DATA_LENGTH];
    for (i=0;i<AFE_DATA_LENGTH;i++){
        cTempTx[i]=0x00;
        cTempRx[i]=0xFF;
    }


    transaction.count = AFE_DATA_LENGTH;
    transaction.txBuf = cTempTx;
    i=NextScanBuffer();
    //i=0;
    if (i==0){
        ptrbuf=cExternalbuffer;            //returns required address in global variable ptrbuf
        iPacketNumber=0;
        //return AFE_DATA_LENGTH;          // no. of bytes that has been received
    }
    transaction.rxBuf = ptrbuf;
    transaction.arg=&iIntCount;
    //PIN_setOutputValue(hCpuPins,3,0);
   // PIN_setOutputValue(hCpuPins,3,1);

    b1=SPI_transfer(handle_spi, &transaction);
    DelayuS(50);

    if(!b1){
    //PIN_setInterrupt(hCpuPins, 4|PIN_IRQ_NEGEDGE);
    return AFE_TRANSFER_ERR;                        // returns error condition
    }

    return AFE_DATA_LENGTH;                         // no. of bytes that has been received
}

/**----------------------------------------------------------------
Void spiCallback (SPI_Handle handle, SPI_Transaction *transaction)

------------------------------------------------------------------*/
void SPICallbackFunction (SPI_Handle handle_spi, SPI_Transaction *pTransaction)
{

    void *ptr;
    int i,j,k;
    char ch;

    if (transaction.status==SPI_TRANSFER_COMPLETED){


        cSpiTxferCmplete=1 ;// indicate that process buffer increment is in processs
        chr0x33= (iSpiCount & 0xff);
        j=ScanBuffer.iCount;
        if (j<SCAN_BUF_SIZE) {
            i=ScanBuffer.iIptr; //move in pointer forward
            i++;
            if (i>=SCAN_BUF_SIZE) i=0;
             ScanBuffer.iIptr=i;
             ScanBuffer.iCount++;
        }
        cSpiTxferCmplete=0; //// indicates that process buffer increment is compeleted
        //Event_post(syncEvent, 1);
    } else {
        chr0x33=0x44;
    }
   // PIN_setOutputValue(hCpuPins,3,1);

}




/**----------------------------------------------------------------------
 * int ReadDataFromAFEasynchronous(void)
 * Read the
 * input: iCount: no of bytes to be sent
 * returns: AFE_TRANSFER_ERR(-1) if transfer counld not take palce
 *          else, no. of bytes that have bene received as reply
 *          (0 or more- depends on iRecv COunt specified)
 ----------------------------------------------------------------------*/
int ReadDataFromAFEasynchronous_Debug(void)
{
int i;
uint8_t *ptr2RxBuf;

    bool b1;

    uint8_t cTempTx[100];
    uint8_t cTempRx[100];
    for (i=0;i<AFE_DATA_LENGTH;i++){
        cTempTx[i]=0x00;
        cTempRx[i]=0xFF;
    }


    transaction.count = AFE_DATA_LENGTH;
    transaction.txBuf = cTempTx;
    i=NextScanBuffer();

    if (i==0){
        ptrbuf=cExternalbuffer;            //returns required address in global variable ptrbuf
        iPacketNumber=0;
        //return AFE_DATA_LENGTH;          // no. of bytes that has been received
    }
    ptrbuf1=cExternalbuffer;            //returns required address in global variable ptrbuf

    transaction.rxBuf = ptrbuf1;
    //transaction.rxBuf = ptrbuf;
    transaction.arg=&iIntCount;
    b1=SPI_transfer(handle_spi, &transaction);

    //Over wite the adc value wiht the dummy value
     ptr2RxBuf = ptrbuf;
     for(i=0;i<9;i++){
         *ptr2RxBuf=0x0;ptr2RxBuf++;
         *ptr2RxBuf=0x0;;ptr2RxBuf++;
         *ptr2RxBuf=iPacketNumber2 & 0XFF;ptr2RxBuf++;
     }


    if(!b1){
    //PIN_setInterrupt(hCpuPins, AFE_DRDY|PIN_IRQ_NEGEDGE);
    return AFE_TRANSFER_ERR;                        // returns error condition
    }
    return AFE_DATA_LENGTH;                         // no. of bytes that has been received
}


//////////////////////////////////////////////////////////////////////////////////////////
/**----------------------------------------------------------------
void AFEinit(void)
Initialises AFE
input: none
returns:AFE_INIT_ERROR(0) if Init not succesful, AFE_INIT_SUCCESS(1) if succesful
----------------------------------------------------------------*/
int AFEinit3(void)
{
int i,j,ch;



// test rouitne to check the gpio

PIN_init(BoardGpioInitTable1);
hCpuPins= PIN_open(&pinState,BoardGpioInitTable1);
//
//
//
////deBUG
//
////PIN_setOutputValue(hCpuPins, AFE_CS,0);//CONFIG_SPI_0 MOSI
////PIN_setOutputValue(hCpuPins,1,0);//CONFIG_SPI_0 SCLK
////PIN_setOutputValue(hCpuPins,3,0);//CONFIG_SPI_0 CS
//
//cPenidingEvtf=PIN_registerIntCb(hCpuPins,DRDY_Callback);
//
//PIN_setConfig(hCpuPins, PIN_BM_IRQ,4  | PIN_IRQ_NEGEDGE);
//PIN_setInterrupt(hCpuPins, 4|PIN_IRQ_NEGEDGE);
//deBUG




SPI_init();

//-------SPI initalisation-----------
SPI_Params_init(&params_spi);                       // initialises parameters to defaults
params_spi.bitRate  = 500000;
params_spi.transferTimeout=100;
params_spi.transferMode=SPI_MODE_BLOCKING;              //SPI_MODE_CALLBACK;
//params.transferCallbackFxn=SPICallbackFunction;
params_spi.frameFormat = SPI_POL0_PHA1;             // this is Motorola format
params_spi.mode        = SPI_MASTER;
handle_spi = SPI_open(0, &params_spi);              // initialise SPI


//handle_spi;
spiHandle=handle_spi;
bDataReadinProgress=0;


if (!spiHandle) {
    iSPIStatus=0;
    return AFE_INIT_ERROR;
} else {
    iSPIStatus=1;                                       // MARK SPI open is succesful
}


HardwareResetAFE();
ResetAFE();
DelayuS(10);
AFEChipSelect();
DelayuS(10);

cSpiTxBuffer[0] = AFE_OPCODE_STOP;
cSpiTxBuffer[1] = AFE_OPCODE_SDATAC;
cSpiTxBuffer[2] = AFE_OPCODE_RREG | AFE_ID;
cSpiTxBuffer[3] = 0;                             // we need to read one ID register
cSpiTxBuffer[4] = 0xFF;
i=SendtoAFE2 (4,1);                             //Read ID byte. It should be 0x92
if (i==AFE_TRANSFER_ERR){
    return AFE_INIT_ERROR;
}
if (cSpiRxBuffer1[0]!=AFE_DEFINED_ID){
    return AFE_INIT_ERROR;
}

DelayuS(10);

//-------------------------------------------------------------------------------------------------------------------------

//--------------------configuration1 AS PER THE DATASHEET ------------------------


cSpiTxBuffer[0] = AFE_OPCODE_SDATAC;
i=SendtoAFE2(1,0);

cSpiTxBuffer[0] = AFE_OPCODE_RESET;
i=SendtoAFE2(1,0);
DelayuS(10); //internal voltage startup time

i=0;
cSpiTxBuffer[i++] = AFE_OPCODE_WREG | AFE_CONFIG3;
cSpiTxBuffer[i++] = 0x00;
cSpiTxBuffer[i++] =0xCC;//0xC6;   //fed externallyAVSS+AVDD/2 externally; 0x04  RLD AmplifierEnabled

//cSpiTxBuffer[i++] =0xCC;   //fed externallyAVSS+AVDD/2 externally; 0x04  RLD AmplifierEnabled

i=SendtoAFE2 (i,40);                             //Read ID byte. It should be 0x92
DelayuS(15000); //internal voltage startup time=150ms

cSpiTxBuffer[0] = AFE_OPCODE_RREG | AFE_ID;
cSpiTxBuffer[1] = 19;                                   // we need to read one ID register
cSpiTxBuffer[2] = 0xFF;
i=SendtoAFE2 (2,40);

i=0;
cSpiTxBuffer[i++] = AFE_OPCODE_WREG | AFE_CONFIG1;
cSpiTxBuffer[i++] = 0x00;
cSpiTxBuffer[i++] = 0x85;
//cSpiTxBuffer[i++] = 0x85;
                                    //D2:0 data output rate
                                        //06=250 SPS,04=1KSPS,03=2kSPS
                                        // D8=0 LP mode, 1 HR mode
i=SendtoAFE2 (i,40);

i=0;
cSpiTxBuffer[0] = AFE_OPCODE_RREG | AFE_ID;
cSpiTxBuffer[1] = 19;                                   // we need to read one ID register
cSpiTxBuffer[2] = 0xFF;
i=SendtoAFE2 (2,40);
i=0;

cSpiTxBuffer[i++] = AFE_OPCODE_WREG | AFE_CONFIG2;
cSpiTxBuffer[i++] = 0x00;
//cSpiTxBuffer[i++] =0x00;                  //NO_INTERNAL_TEST_SIGNAL;
cSpiTxBuffer[i++] =0x00;       //0xx000             //INTERNAL_TEST_SIGNAL ON;                       //D4=INT_TEST=1 generates internal etst signal, =0 no test signal
                                        //D1:0=00 or 01 decides freq of test signal
                                        // D2=amplitude 0 lower, 1 higher amplitude

i=SendtoAFE2 (i,40);

i=0;
cSpiTxBuffer[0] = AFE_OPCODE_RREG | AFE_ID;
cSpiTxBuffer[1] = 19;                                   // we need to read one ID register
cSpiTxBuffer[2] = 0xFF;
i=SendtoAFE2 (2,40);
i=0;

//cSpiTxBuffer[i++] = AFE_OPCODE_WREG | AFE_LOFF;
//cSpiTxBuffer[i++] = 0x00;
//cSpiTxBuffer[i++] = 0xF3;
//                                        //RLDREF signalis internal
//i=SendtoAFE2 (i,40);
//
//i=0;
//cSpiTxBuffer[0] = AFE_OPCODE_RREG | AFE_ID;
//cSpiTxBuffer[1] = 19;                                   // we need to read one ID register
//cSpiTxBuffer[2] = 0xFF;
//i=SendtoAFE2 (2,40);
//i=0;
//

cSpiTxBuffer[i++] = AFE_OPCODE_WREG | AFE_CH1SET;           //   D6:4 PGA gain .
                                                            //      000=gain 6
                                                            //      001=gain 1
                                                            //      010=gain 2
                                                            //      011=gain 3
                                                            //      100=gain 4
                                                            //      101=gain 8
                                                            //      110=gain 12

                                                            // D2:0 =00 external signal
                                                            //      =001input shorted
                                                            //      =101 test signal

cSpiTxBuffer[i++] =0x00;
//cSpiTxBuffer[i++] = 0x20;  // 0x10;  //external signal channel
cSpiTxBuffer[i++] =0x10;//NOISE_MEASUREMENT|CH_PDWN;////VOLTAGE_MEASUREMENT; //NOISE_MEASUREMENT;  // internal signal
i=SendtoAFE2 (i,20);

i=0;
cSpiTxBuffer[0] = AFE_OPCODE_RREG | AFE_ID;
cSpiTxBuffer[1] = 19;                                   // we need to read one ID register
cSpiTxBuffer[2] = 0xFF;
i=SendtoAFE2 (2,40);
i=0;


#if Jorjin
cSpiTxBuffer[i++] = AFE_OPCODE_WREG | AFE_CH2SET;
cSpiTxBuffer[i++] =0x00;
cSpiTxBuffer[i++] =0x65;//NOISE_MEASUREMENT|CH_PDWN;//CH_GAIN|CH2_P_RLD; //Channel 2 RLD Enabled // EXTERNAL_SIG
                        /////NOISE_MEASUREMENT|CH_PDWN;////;//INTERNAL_TEST_SIGNAL_CH; //NOISE_MEASUREMENT|CH_PDWN;//VOLTAGE_MEASUREMENT;//NOISE_MEASUREMENT;
i=SendtoAFE2 (i,40);

i=0;
cSpiTxBuffer[0] = AFE_OPCODE_RREG | AFE_ID;
cSpiTxBuffer[1] = 19;                                   // we need to read one ID register
cSpiTxBuffer[2] = 0xFF;
i=SendtoAFE2 (2,40);
i=0;

cSpiTxBuffer[i++] = AFE_OPCODE_WREG | AFE_CH3SET;
cSpiTxBuffer[i++] =0x00;
cSpiTxBuffer[i++] =0x10;//NOISE_MEASUREMENT|CH_PDWN;//0x15;//NOISE_MEASUREMENT|CH_PDWN;//0x00;//0x10;//NOISE_MEASUREMENT|CH_PDWN;//NOISE_MEASUREMENT;    //Noise measurement

i=SendtoAFE2 (i,40);

i=0;


#else

cSpiTxBuffer[i++] = AFE_OPCODE_WREG | AFE_CH2SET;
cSpiTxBuffer[i++] =0x00;
cSpiTxBuffer[i++] =0x10;//NOISE_MEASUREMENT|CH_PDWN;//CH_GAIN|CH2_P_RLD; //Channel 2 RLD Enabled // EXTERNAL_SIG
                        /////NOISE_MEASUREMENT|CH_PDWN;////;//INTERNAL_TEST_SIGNAL_CH; //NOISE_MEASUREMENT|CH_PDWN;//VOLTAGE_MEASUREMENT;//NOISE_MEASUREMENT;
i=SendtoAFE2 (i,40);

i=0;
cSpiTxBuffer[0] = AFE_OPCODE_RREG | AFE_ID;
cSpiTxBuffer[1] = 19;                                   // we need to read one ID register
cSpiTxBuffer[2] = 0xFF;
i=SendtoAFE2 (2,40);
i=0;

cSpiTxBuffer[i++] = AFE_OPCODE_WREG | AFE_CH3SET;
cSpiTxBuffer[i++] =0x00;
cSpiTxBuffer[i++] =0x15;//NOISE_MEASUREMENT|CH_PDWN;//0x15;//NOISE_MEASUREMENT|CH_PDWN;//0x00;//0x10;//NOISE_MEASUREMENT|CH_PDWN;//NOISE_MEASUREMENT;    //Noise measurement

i=SendtoAFE2 (i,40);

i=0;

#endif





cSpiTxBuffer[0] = AFE_OPCODE_RREG | AFE_ID;
cSpiTxBuffer[1] = 19;                                   // we need to read one ID register
cSpiTxBuffer[2] = 0xFF;
i=SendtoAFE2 (2,40);
i=0;

cSpiTxBuffer[i++] = AFE_OPCODE_WREG | AFE_CH4SET;
cSpiTxBuffer[i++] = 0x00;
cSpiTxBuffer[i++] =0x10;//NOISE_MEASUREMENT|CH_PDWN;;//NOISE_MEASUREMENT; //noise  masurement
i=SendtoAFE2 (i,40);

i=0;
cSpiTxBuffer[0] = AFE_OPCODE_RREG | AFE_ID;
cSpiTxBuffer[1] = 19;                                   // we need to read one ID register
cSpiTxBuffer[2] = 0xFF;
i=SendtoAFE2 (2,40);
i=0;

cSpiTxBuffer[i++] =AFE_OPCODE_WREG | AFE_CH5SET;
cSpiTxBuffer[i++] =0x00;
cSpiTxBuffer[i++] =0x10;//NOISE_MEASUREMENT|CH_PDWN;//0x10;//NOISE_MEASUREMENT|CH_PDWN;;//|CH_PDWN;//NOISE_MEASUREMENT;//internal test signal CH_GAIN|CH2_P_RLD

i=SendtoAFE2 (i,40);

i=0;
cSpiTxBuffer[0] = AFE_OPCODE_RREG | AFE_ID;
cSpiTxBuffer[1] = 19;                                   // we need to read one ID register
cSpiTxBuffer[2] = 0xFF;
i=SendtoAFE2 (2,40);
i=0;

cSpiTxBuffer[i++] = AFE_OPCODE_WREG | AFE_CH6SET;
cSpiTxBuffer[i++] = 0x00;
cSpiTxBuffer[i++] =0x10;//NOISE_MEASUREMENT|CH_PDWN;//VOLTAGE_MEASUREMENT; EXTERNAL_SIG//NOISE_MEASUREMENT;//internal test signal
                                                // D6:4 = GAIN..
                                                // 000=6,001=1,010=2,011=3,100=4,101=8,110=12
i=SendtoAFE2 (i,40);

i=0;
cSpiTxBuffer[0] = AFE_OPCODE_RREG | AFE_ID;
cSpiTxBuffer[1] = 19;                                   // we need to read one ID register
cSpiTxBuffer[2] = 0xFF;
i=SendtoAFE2 (2,40);
i=0;


cSpiTxBuffer[i++] = AFE_OPCODE_WREG | AFE_CH7SET;
cSpiTxBuffer[i++] = 0x00;
cSpiTxBuffer[i++] =0x10;//NOISE_MEASUREMENT|CH_PDWN;//NOISE_MEASUREMENT|CH_PDWN;//INTERNAL_TEST_SIGNAL_CH; //EXTERNAL_SIG;//NOISE_MEASUREMENT;//internal test signal                                   //   gain is 3 and test signal is given as input for mux
i=SendtoAFE2 (i,40);

i=0;
cSpiTxBuffer[0] = AFE_OPCODE_RREG | AFE_ID;
cSpiTxBuffer[1] = 19;                                   // we need to read one ID register
cSpiTxBuffer[2] = 0xFF;
i=SendtoAFE2 (2,40);
i=0;

cSpiTxBuffer[i++] = AFE_OPCODE_WREG | AFE_CH8SET;
cSpiTxBuffer[i++] = 0x00;
cSpiTxBuffer[i++] =0x10;// NOISE_MEASUREMENT|CH_PDWN;//INTERNAL_TEST_SIGNAL_CH;;//EXTERNAL_SIG; //internal test signal                                  //   gain is 3 and test signal is given as input for mux
i=SendtoAFE2 (i,40);


i=0;
cSpiTxBuffer[0] = AFE_OPCODE_RREG | AFE_ID;
cSpiTxBuffer[1] = 19;
cSpiTxBuffer[2] = 0xFF;
i=SendtoAFE2 (2,40);
i=0;

//////////////////////////////////////////////RLD SENSE/////////////////////////////////////////////////////////////
#if Jorjin


cSpiTxBuffer[i++] = AFE_OPCODE_WREG | AFE_RLD_SENSP;//sense 7
cSpiTxBuffer[i++] = 0x00;
cSpiTxBuffer[i++] = 0x04;//NOISE_MEASUREMENT|CH_PDWN;//INTERNAL_TEST_SIGNAL_CH; //EXTERNAL_SIG;//NOISE_MEASUREMENT;//internal test signal                                   //   gain is 3 and test signal is given as input for mux
i=SendtoAFE2 (i,40);
//
//
i=0;
cSpiTxBuffer[0] = AFE_OPCODE_RREG | AFE_ID;
cSpiTxBuffer[1] = 19;                                   // we need to read one ID register
cSpiTxBuffer[2] = 0xFF;
i=SendtoAFE2 (2,40);
i=0;
//
//
//
//

cSpiTxBuffer[i++] = AFE_OPCODE_WREG | AFE_RLD_SENSN; //sense 7
cSpiTxBuffer[i++] = 0x00;
cSpiTxBuffer[i++] = 0x04;    ;//NOISE_MEASUREMENT|CH_PDWN;//INTERNAL_TEST_SIGNAL_CH; //EXTERNAL_SIG;//NOISE_MEASUREMENT;//internal test signal                                   //   gain is 3 and test signal is given as input for mux
i=SendtoAFE2 (i,40);

i=0;
cSpiTxBuffer[0] = AFE_OPCODE_RREG | AFE_ID;
cSpiTxBuffer[1] = 19;                                   // we need to read one ID register
cSpiTxBuffer[2] = 0xFF;
i=SendtoAFE2 (2,40);
i=0;
#else
cSpiTxBuffer[i++] = AFE_OPCODE_WREG | AFE_RLD_SENSP;//sense 7
cSpiTxBuffer[i++] = 0x00;
cSpiTxBuffer[i++] = 0x02;//NOISE_MEASUREMENT|CH_PDWN;//INTERNAL_TEST_SIGNAL_CH; //EXTERNAL_SIG;//NOISE_MEASUREMENT;//internal test signal                                   //   gain is 3 and test signal is given as input for mux
i=SendtoAFE2 (i,40);
//
//
i=0;
cSpiTxBuffer[0] = AFE_OPCODE_RREG | AFE_ID;
cSpiTxBuffer[1] = 19;                                   // we need to read one ID register
cSpiTxBuffer[2] = 0xFF;
i=SendtoAFE2 (2,40);
i=0;
//
//
//
//

cSpiTxBuffer[i++] = AFE_OPCODE_WREG | AFE_RLD_SENSN; //sense 7
cSpiTxBuffer[i++] = 0x00;
cSpiTxBuffer[i++] = 0x02;    ;//NOISE_MEASUREMENT|CH_PDWN;//INTERNAL_TEST_SIGNAL_CH; //EXTERNAL_SIG;//NOISE_MEASUREMENT;//internal test signal                                   //   gain is 3 and test signal is given as input for mux
i=SendtoAFE2 (i,40);

i=0;
cSpiTxBuffer[0] = AFE_OPCODE_RREG | AFE_ID;
cSpiTxBuffer[1] = 19;                                   // we need to read one ID register
cSpiTxBuffer[2] = 0xFF;
i=SendtoAFE2 (2,40);
i=0;

#endif
//////////////////////////////////////////////RLD SENSE/////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
cSpiTxBuffer[i++] = AFE_OPCODE_WREG |AFE_WCT1;
cSpiTxBuffer[i++] = 0x00;
cSpiTxBuffer[i++] =0x0b; //wct1 connected to ra lead1 channel1=0x09  //chanel2=0x0b                     //
i=SendtoAFE2 (i,40);

i=0;
cSpiTxBuffer[0] = AFE_OPCODE_RREG | AFE_ID;
cSpiTxBuffer[1] = 19;                                   // we need to read one ID register
cSpiTxBuffer[2] = 0xFF;
i=SendtoAFE2 (2,40);
i=0;



cSpiTxBuffer[i++] = AFE_OPCODE_WREG |AFE_WCT2;
cSpiTxBuffer[i++] = 0x00;
cSpiTxBuffer[i++] =0x50;// //wctb connected to LA lead1                   //
i=SendtoAFE2 (i,40);

i=0;
cSpiTxBuffer[0] = AFE_OPCODE_RREG | AFE_ID;
cSpiTxBuffer[1] = 19;                                   // we need to read one ID register
cSpiTxBuffer[2] = 0xFF;
i=SendtoAFE2 (2,40);

//cSpiTxBuffer[i] = 0xFF;
//i=SendtoAFE2 (i,0);                               //Read ID byte. It should be 0x92
if (i==AFE_TRANSFER_ERR){
    return AFE_INIT_ERROR;
}
ResetScanBuffer();

cSpiTxBuffer[0] = AFE_OPCODE_RREG | AFE_ID;
cSpiTxBuffer[1] = 19;                                   // we need to read one ID register
cSpiTxBuffer[2] = 0xFF;
i=SendtoAFE2 (2,40);


cSpiTxBuffer[0] = AFE_OPCODE_STOP;
i=SendtoAFE2 (1,0);

cSpiTxBuffer[0] = AFE_OPCODE_SDATAC;
i=SendtoAFE2 (1,0);
DelayuS(10000);
DelayuS(10000);
DelayuS(10000);
DelayuS(10000);
DelayuS(10000);
DelayuS(10000);



ResetScanBuffer();
cSpiTxferCmplete=0;

DelayuS(10);
DelayuS(10);
DelayuS(10);

Error_init(&eb);
Swi_Params_init(&swiParams);


hswiDRDY = Swi_create((ti_sysbios_knl_Swi_FuncPtr)swiDRDYFunction, &swiParams,&eb);     // this sofwtare interrupt will be generated by DRDY HWI

if (hswiDRDY == NULL) {
    return AFE_INIT_ERROR;                          // eror occured while creating drdry function

}

//PIN_setConfig(hCpuPins, PIN_BM_IRQ, 4   | PIN_IRQ_NEGEDGE);
//PIN_setInterrupt(hCpuPins, 4|PIN_IRQ_NEGEDGE);




//////i=cPenidingEvtf;
////
////
////
//pin_cfg = PIN_getConfig(4);
//PIN_add(hCpuPins, pin_cfg);
//irq_cfg = pin_cfg & PIN_BM_IRQ;
//PIN_setInterrupt(hCpuPins, 4 | irq_cfg);




//PIN_Config pin_cfg;
// 153   PIN_Config irq_cfg;4
// 154
// 155   pin_cfg = PIN_getConfig(pin);
// 156   PIN_add(pin_handle, pin_cfg);
// 157
// 158   irq_cfg = pin_cfg & PIN_BM_IRQ;
// 159   PIN_setInterrupt(pin_handle, pin | irq_cfg);

//PIN_init(BoardGpioInitTable1);
//hCpuPins= PIN_open(&pinState,BoardGpioInitTable1);






//---------------------------------------------------------

AFEstart();
DelayuS(10);

cSpiTxBuffer[0] = AFE_OPCODE_RDATAC;
SendtoAFE (handle_spi,1,0);                                 //restart continuous read

AFEChipUnSelect();
DelayuS(10);
AFEChipSelect();

SPI_close(handle_spi);
SPI_init();
SPI_Params_init(&params_spi);
params_spi.frameFormat =  SPI_POL0_PHA1;             // this is Motorola format
params_spi.bitRate  =4000000;  //4mhz
params_spi.transferTimeout=1000;
params_spi.mode        = SPI_MASTER;
params_spi.transferMode=SPI_MODE_CALLBACK;//SPI_MODE_BLOCKING
params_spi.transferCallbackFxn=SPICallbackFunction;
handle_spi = SPI_open(SPI0, &params_spi);               // initialise SPI

DelayuS(10);
cInterprocessSem=0;



//hCpuPins= PIN_open(&pinState,& Pin);

cPenidingEvtf=PIN_registerIntCb(hCpuPins, DRDY_Callback);
////i=cPenidingEvtf;
//
//
//
PIN_setConfig(hCpuPins, PIN_BM_IRQ, 4   | PIN_IRQ_NEGEDGE);
PIN_setInterrupt(hCpuPins, 4|PIN_IRQ_NEGEDGE);

return AFE_INIT_SUCCESS;

}

/**----------------------------------------------------------
void PutDataIntoScanBuffer(void)
Puts one scan data of 27 bytes ifromSPiReceive buffer intto next available scan buffer
input: none . takes global storage for spi receive buffer
returns:0 if no data, 1 if data read into SPI receive buffer
------------------------------------------------------------*/
int GetDataFromScanBuffer(void)
{
int i,j,k;
//if (iInNextScanBuffer==0) return 0;
cBleTxferCmplete=1;
//iInGetData=1;
if (ScanBuffer.iOverrunFlag>0){
    for (i=0;i<27;i++){
        cSpiRxBuffer2[i]=0xAA;
    }
    return 1;
}
j=ScanBuffer.iOptr;                 //Transfer Data to Scan buffer at In pointer
for (i=0;i<27;i++){
    cSpiRxBuffer2[i]=ScanBuffer.ScanData[j].cOneScanData[i];
}
j++;
if (j>=SCAN_BUF_SIZE) j=0;
ScanBuffer.iOptr=j;
ScanBuffer.iCount--;
cBleTxferCmplete=0;
//iInGetData=0;
return 1;
}

/****************************************************************************************8
Sydantek_Afeinit()

****************************************************************************************/

void Sydantek_Afeinit()
{
uint8_t status,statusbreakpoint;
   while(1){
    status=AFEinit3();
    if(status!=0){
        break;
    }else{
        statusbreakpoint=0;
    }
   }

}



/////****************************************************************************************8
////Sydantek_Afeinit()
////
////****************************************************************************************/
char Sydantek_ProcessTimerEvent() {
    static uint32_t attempts = 0;
    static uint32_t successes = 0;
    static uint32_t serial = 0xa0000000;
    union {
     uint32_t l1;
     char c1[4];
    } uGettime;
    int i1=0,i2=0,i3=0,i4=0,ix,jx,i;
    attHandleValueNoti_t notification;
    bStatus_t status;



     gattAttribute_t* attribute = GATTServApp_FindAttr(
                attributes, GATT_NUM_ATTRS(attributes), notify);
     notification.handle = attribute->handle;

        for ( i = 0; i < linkDBNumConns; ++i) {
            gattCharCfg_t *item = notify_config + i;
            if (item->connHandle == LINKDB_CONNHANDLE_INVALID) continue;
            if (item->value == GATT_CFG_NO_OPERATION) continue;


            ix=ScanBuffer.iCount;

            if (ix<10) return 0;          //frame is muvutiple is 10
            jx=(ix/10);

            for (int k = 0; k < jx; ++k) {
                notification.pValue = (uint8_t*) GATT_bm_alloc(
                        item->connHandle, ATT_HANDLE_VALUE_NOTI, PAYLOAD_BYTES,
                        &notification.len);
                if (!notification.pValue) break;

                uint8_t* pointer = notification.pValue;

                if (ScanBuffer.iCount>=10){   // data is not yet available, so wait for it
                 i3=1;
                for (i2=0;i2<10;i2++){
                   i1=GetDataFromScanBuffer();
                       if (i1!=0){

                               //for(i4=0;i4<8;i4++){
                              cTempBfr[0][(i2*3)]=cSpiRxBuffer2[LEAD_1];//contain channel 1 ist byte the 3bytes
                              cTempBfr[0][(i2*3)+1]=cSpiRxBuffer2[LEAD_1+1];//contain channel 2 the 2 bytes
                              cTempBfr[0][(i2*3)+2]=cSpiRxBuffer2[LEAD_1+2];//contain the 3bytes

                              cTempBfr[1][(i2*3)]=cSpiRxBuffer2[LEAD_2];//contain channel 1 ist byte the 3bytes
                              cTempBfr[1][(i2*3)+1]=cSpiRxBuffer2[LEAD_2+1];//contain channel 2 the 2 bytes
                              cTempBfr[1][(i2*3)+2]=cSpiRxBuffer2[LEAD_2+2];//contain the 3bytes

                              cTempBfr[2][(i2*3)]=cSpiRxBuffer2[V1];//contain channel 1 ist byte the 3bytes
                              cTempBfr[2][(i2*3)+1]=cSpiRxBuffer2[V1+1];//contain channel 2 the 2 bytes
                              cTempBfr[2][(i2*3)+2]=cSpiRxBuffer2[V1+2];//contain the 3bytes

                              cTempBfr[3][(i2*3)]=cSpiRxBuffer2[V2];//contain channel 1 ist byte the 3bytes
                              cTempBfr[3][(i2*3)+1]=cSpiRxBuffer2[V2+1];//contain channel 2 the 2 bytes
                              cTempBfr[3][(i2*3)+2]=cSpiRxBuffer2[V2+2];//contain the 3bytes


                              cTempBfr[4][(i2*3)]=cSpiRxBuffer2[V3];//contain channel 1 ist byte the 3bytes
                              cTempBfr[4][(i2*3)+1]=cSpiRxBuffer2[V3+1];//contain channel 2 the 2 bytes
                              cTempBfr[4][(i2*3)+2]=cSpiRxBuffer2[V3+2];//contain the 3bytes

                              cTempBfr[5][i2*3]=cSpiRxBuffer2[V4];//contain channel 1 ist byte the 3bytes
                              cTempBfr[5][(i2*3)+1]=cSpiRxBuffer2[V4+1];//contain channel 2 the 2 bytes
                              cTempBfr[5][(i2*3)+2]=cSpiRxBuffer2[V4+2];//contain the 3bytes

                              cTempBfr[6][i2*3]=cSpiRxBuffer2[V5];//contain channel 1 ist byte the 3bytes
                              cTempBfr[6][(i2*3)+1]=cSpiRxBuffer2[V5+1];//contain channel 2 the 2 bytes
                              cTempBfr[6][(i2*3)+2]=cSpiRxBuffer2[V5+2];//contain the 3bytes

                              cTempBfr[7][i2*3]=cSpiRxBuffer2[V6];//contain channel 1 ist byte the 3bytes
                              cTempBfr[7][(i2*3)+1]=cSpiRxBuffer2[V6+1];//contain channel 2 the 2 bytes
                              cTempBfr[7][(i2*3)+2]=cSpiRxBuffer2[V6+2];//contain the 3bytes


                           //}

                    }
                }
            }

            *(uint32_t*) pointer = serial;
             pointer+=4;
//            *(uint32_t*) (pointer + notification.len - 4) =serial;
//            *(uint32_t*) (pointer + notification.len - 4)  =serial;
            for(i4=0;i4<10;i4++){
                        for (i2=0;i2<8;i2++){
                            // big endian
//                            *pointer= 0x55;//cTempBfr[i4][(i2*3)];
//                             pointer++;
//                            *pointer= cTempBfr[i4][(i2*3)+1];
//                             pointer++;
//                            *pointer= cTempBfr[i4][(i2*3)+2];
//                             pointer++;

                             // little endian
                             *pointer=cTempBfr[i2][(i4*3)+2];
                              pointer++;
                             *pointer=cTempBfr[i2][(i4*3)+1];
                              pointer++;
                             *pointer=cTempBfr[i2][(i4*3)];;
                              pointer++;
                        }
               }

                   //iPacketNumber++;
               ++attempts;
                if(i3==1){
                    status = GATT_Notification(item->connHandle, &notification, FALSE);
                    if (status != SUCCESS) {
                        //Log_info1("Notification: status=%d", status);
                        GATT_bm_free((gattMsg_t *) &notification, ATT_HANDLE_VALUE_NOTI);
                        --serial; //sequence  count will  not decrement when data is runing
                        return 0; // it will not reset

                    } else {
                        ++successes;
                        ++serial;
                    }
               }
            }
        }
        return 0;

}










//void Sydantek_ProcessTimerEvent() {
//    static uint32_t count = 0;
//    static uint32_t attempts = 0;
//    static uint32_t successes = 0;
//    static uint32_t serial = 0xa0000000;
//    //keep
//    //PIN_setOutputValue(hCpuPins,3,1);//CONFIG_SPI_0 CS
//
//
//    if (++count % 1000 == 0 || count == 1) {
//        ICall_heapStats_t stats;
//        ICall_getHeapStats(&stats);
//        Log_info3("@ heap: %u total, %u free, %u largest",
//                  stats.totalSize, stats.totalFreeSize, stats.largestFreeSize);
//        Log_info3("count %d, attempts %d, successes %d", count, attempts, successes);
//    }
//
//    attHandleValueNoti_t notification;
//    bStatus_t status;
//
//    gattAttribute_t* attribute = GATTServApp_FindAttr(
//            attributes, GATT_NUM_ATTRS(attributes), notify);
//    notification.handle = attribute->handle;
//
//    for (int i = 0; i < linkDBNumConns; ++i) {
//        gattCharCfg_t *item = notify_config + i;
//        if (item->connHandle == LINKDB_CONNHANDLE_INVALID) continue;
//        if (item->value == GATT_CFG_NO_OPERATION) continue;
//
//        for (int k = 0; k < 6; ++k) {
//            notification.pValue = (uint8_t*) GATT_bm_alloc(
//                    item->connHandle, ATT_HANDLE_VALUE_NOTI, PAYLOAD_BYTES,
//                    &notification.len);
//            if (!notification.pValue) break;
//
//            uint8_t* pointer = notification.pValue;
//            *(uint32_t*) pointer = serial;
//            *(uint32_t*) (pointer + notification.len - 4) = serial;
//
//            ++attempts;
//            status = GATT_Notification(item->connHandle, &notification, FALSE);
//            if (status != SUCCESS) {
//                Log_info1("Notification: status=%d", status);
//                GATT_bm_free((gattMsg_t *) &notification, ATT_HANDLE_VALUE_NOTI);
//            } else {
//                ++successes;
//                ++serial;
//            }
//        }
//    }
//   // PIN_setOutputValue(hCpuPins,3,0);//CONFIG_SPI_0 CS
//
//}
//
//
//
